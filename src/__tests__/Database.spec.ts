import { XUtils } from "@vex-chat/crypto";
import * as XTypes from "@vex-chat/types";
import { Database } from "../Database";
import { ISpireOptions } from "../Spire";

// Mock UUID to ensure deterministic IDs in tests
jest.mock("uuid", () => {
    return {
        v4: jest.fn(() => "93ce482b-a0f2-4f6e-b1df-3aed61073552"),
        validate: jest.fn(() => true),
    };
});

describe("Database", () => {
    // Reusable test data
    const keyID = "de459e05-aa63-4dfa-97b4-ed43d5c7a5f7"; // Not used in insert (generated by db), but useful for ref
    const userID = "4e67b90f-cbf8-44bc-8ce3-d3b248f033f1";
    const deviceID = "23cb0b27-7d0c-43b2-87e1-c2b93e0095e5";

    // "30c2..."
    const publicKeyHex = "30c2d0294c1cfdbb73c6b3bbe6010088c2dba8384b04ff2e2b92172431d66b5e";
    const publicKey = XUtils.decodeHex(publicKeyHex);

    // "dd06..."
    const signatureHex = "dd0665079426c3efcf4dce9b1487e4aca132f8147581b3294c3f23ddd2b4ba8240a10082bd06805d7eb320d91af971da3306e11b60073ccc3d829710f5036004000030c2d0294c1cfdbb73c6b3bbe6010088c2dba8384b04ff2e2b92172431d66b5e";
    const signature = XUtils.decodeHex(signatureHex);

    const testSQLPreKey: XTypes.IPreKeysSQL = {
        userID,
        keyID: "93ce482b-a0f2-4f6e-b1df-3aed61073552", // Matches the mocked UUID
        deviceID,
        publicKey: publicKeyHex,
        signature: signatureHex,
        index: 1,
    };

    const testWSPreKey: XTypes.IPreKeysWS = {
        publicKey,
        signature,
        deviceID,
        index: 1,
    };

    const options: ISpireOptions = {
        dbType: "sqlite3mem",
        logLevel: "error"
    };

    let db: Database;

    // Initialize DB and wait for migrations before every test
    beforeEach(async () => {
        db = new Database(options);
        await new Promise<void>((resolve) => db.on("ready", resolve));
    });

    // Clean up connection after every test
    afterEach(async () => {
        await db.close();
    });

    describe("saveOTK", () => {
        it("takes a userId and one time key, adds a keyId and saves it to oneTimeKey table", async () => {
            // Arrange
            const inputOTK: XTypes.IPreKeysWS = {
                publicKey,
                signature,
                index: 1,
                deviceID,
            };

            // Act
            await db.saveOTK(userID, deviceID, [inputOTK]);

            // Assert
            // Note: getOTK in Database.ts deletes the key after retrieval (delete-on-read)
            const retrievedKey = await db.getOTK(deviceID);
            
            // We expect the retrieved key to match what we put in
            expect(retrievedKey).toEqual(inputOTK);

            // Verify it was actually deleted (second call should be null)
            const secondCall = await db.getOTK(deviceID);
            expect(secondCall).toBeNull();
        });
    });

    describe("getPreKeys", () => {
        it("returns a preKey by deviceID if said preKey exists", async () => {
            // Arrange
            // We access the private 'db' knex instance to manually insert data for the test setup
            // casting to 'any' to access private property for white-box testing
            await (db as any)["db"]("preKeys").insert(testSQLPreKey);

            // Act
            const result = await db.getPreKeys(deviceID);

            // Assert
            expect(result).toEqual(testWSPreKey);
        });

        it("returns null if there are no preKeys with deviceID param", async () => {
            // Act
            const result = await db.getPreKeys(deviceID);

            // Assert
            expect(result).toBeNull();
        });
    });
});